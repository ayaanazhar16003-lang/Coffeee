<!doctype html>
container.appendChild(card);


// favorite toggle
card.querySelector('.fav').addEventListener('click', ()=>{ if(state.favorites.has(drink.id)) state.favorites.delete(drink.id); else state.favorites.add(drink.id); saveFavorites(); renderResults(list, opts); });


// view details
card.querySelector('button[data-view]').addEventListener('click', ()=>{ showDetails(drink); });
}
}


function showDetails(drink){
// modal-lite: reuse results area to show details temporarily
const modal = document.createElement('div'); modal.className='card';
modal.style.position='fixed'; modal.style.left='50%'; modal.style.top='50%'; modal.style.transform='translate(-50%,-50%)'; modal.style.width='min(720px,92%)'; modal.style.maxHeight='90vh'; modal.style.overflow='auto'; modal.style.zIndex=9999;
modal.innerHTML = `
<div style="display:flex;gap:12px;align-items:center">
<div style="width:88px;height:88px;border-radius:12px;overflow:hidden"><img src="${drink.image}" style="width:100%;height:100%;object-fit:cover"></div>
<div>
<div style="font-weight:800;font-size:20px">${drink.name}</div>
<div class="muted small">${drink.tags.join(' • ')}</div>
</div>
<div style="flex:1"></div>
<button id="closeModal" class="secondary">Close</button>
</div>
<hr>
<div style="display:flex;gap:18px">
<div style="flex:1">
<h4>Ingredients</h4>
<ul>${drink.ingredients.map(i=>`<li>${i}</li>`).join('')}</ul>
<h4>Method</h4>
<ol>${drink.method.map(s=>`<li>${s}</li>`).join('')}</ol>
</div>
<div style="width:240px">
<h4>Description</h4>
<div class="muted">${drink.desc}</div>
<h4 style="margin-top:12px">Notes</h4>
<div class="muted small">This is a suggested method — vary shots and milk ratios to taste.</div>
<div style="margin-top:12px;display:flex;gap:8px"><button id="addFav" class="secondary">${state.favorites.has(drink.id)?'Remove Favorite':'Add Favorite'}</button></div>
</div>
</div>
`;
document.body.appendChild(modal);
document.getElementById('closeModal').addEventListener('click', ()=>modal.remove());
document.getElementById('addFav').addEventListener('click', ()=>{ if(state.favorites.has(drink.id)) state.favorites.delete(drink.id); else state.favorites.add(drink.id); saveFavorites(); modal.remove(); });
}


// ---------- Extra UI handlers ----------
document.getElementById('searchBtn').addEventListener('click', search);
document.getElementById('ingredientInput').addEventListener('keydown', e=>{ if(e.key==='Enter') search(); });
document.getElementById('clearBtn').addEventListener('click', ()=>{ document.getElementById('ingredientInput').value=''; document.getElementById('results').innerHTML=''; document.getElementById('matchesInfo').innerText='Cleared.'; });
document.getElementById('shuffleBtn').addEventListener('click', ()=>{ const r = coffeeDrinks[Math.floor(Math.random()*coffeeDrinks.length)]; document.getElementById('ingredientInput').value = r.ingredients.join(', '); search(); });
document.getElementById('randomMissingBtn').addEventListener('click', ()=>{ // show drinks that are close matches (missing 1 ingredient)
const raw = document.getElementById('ingredientInput').value;
if(!raw) { document.getElementById('matchesInfo').innerText='Type something first'; return; }
const userIngs = raw.split(',').map(s=>normalize(s)).filter(Boolean);
const list = coffeeDrinks.map(d=>{ const ingSet=d.ingredients.map(normalize); let covered=0; for(const u of userIngs){ for(const di of ingSet){ if(di===u || fuzzyMatch(di,u)) { covered++; break;} } } const missing = ingSet.length - covered; return {...d, covered, missing}; }).filter(x=>x.missing>0 && x.missing<=1).sort((a,b)=>a.missing-b.missing);
renderResults(list.map(x=>({...x, matchPct: Math.round((x.covered/x.ingredients.length)*100), score:100 - x.missing*10})));
});


// favorites import/export
document.getElementById('exportFav').addEventListener('click', ()=>{ const data = JSON.stringify(Array.from(state.favorites)); const blob = new Blob([data],{type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='coffee-favs.json'; a.click(); URL.revokeObjectURL(url); });
document.getElementById('importFav').addEventListener('click', ()=>{ document.getElementById('importFile').click(); });
document.getElementById('importFile').addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; const reader=new FileReader(); reader.onload=ev=>{ try{ const arr=JSON.parse(ev.target.result); state.favorites=new Set(arr); saveFavorites(); }catch(err){ alert('Invalid file'); } }; reader.readAsText(f); });


// theme toggle
const themeToggle = document.getElementById('themeToggle'); themeToggle.addEventListener('change', e=>{ if(e.target.checked) { document.documentElement.setAttribute('data-theme','dark'); state.theme='dark'; } else { document.documentElement.removeAttribute('data-theme'); state.theme='light'; } localStorage.setItem('cf_theme', state.theme); });


// init
(function init(){ const saved=document.getItem?localStorage.getItem('cf_theme'):null; if(saved==='dark'){ document.documentElement.setAttribute('data-theme','dark'); themeToggle.checked=true; state.theme='dark'; } loadFavorites(); })();


</script>
</body>
</html>
